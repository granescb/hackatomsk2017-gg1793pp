'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STOP_TIMER = exports.START_TIMER = undefined;
exports.default = timerMiddleware;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var START_TIMER = exports.START_TIMER = 'START_TIMER';
var STOP_TIMER = exports.STOP_TIMER = 'STOP_TIMER';

var provideMessage = function provideMessage(field) {
    return 'You should provide ' + field;
};

function timerMiddleware(_ref) {
    var dispatch = _ref.dispatch;

    var timers = {};

    var clearTimerWithEnd = function clearTimerWithEnd(timerName) {
        var timer = timers[timerName];
        if (timer) {
            clearInterval(timer.interval);
            dispatch({ type: timer.actionName + '_END' });
        }
    };

    return function (next) {
        return function (action) {
            switch (action.type) {
                case START_TIMER:
                    {
                        var _ret = function () {
                            var _action$payload = action.payload,
                                timerName = _action$payload.timerName,
                                actionName = _action$payload.actionName,
                                timerPeriod = _action$payload.timerPeriod,
                                _action$payload$timer = _action$payload.timerInterval,
                                timerInterval = _action$payload$timer === undefined ? 1000 : _action$payload$timer;


                            (0, _invariant2.default)(actionName, provideMessage('actionName'));
                            (0, _invariant2.default)(timerName, provideMessage('timerName'));

                            // if we start timer that already started
                            if (timers[timerName]) {
                                clearInterval(timers[timerName].interval);
                            }
                            // clear
                            timers[timerName] = {};
                            var current = timers[timerName];

                            // set action name
                            current.actionName = actionName;

                            // if timer period provided
                            if (timerPeriod) {
                                current.period = timerPeriod;
                                current.interval = setInterval(function () {
                                    current.period -= 1;
                                    if (current.period === 0) {
                                        clearInterval(current.interval);
                                        // last tick and then end
                                        dispatch({ type: actionName });
                                        // dispatch end action
                                        dispatch({ type: actionName + '_END' });
                                    } else {
                                        dispatch({ type: actionName });
                                    }
                                }, timerInterval);
                            } else {
                                // endless timer - we should stop by hand
                                timers[timerName].interval = setInterval(function () {
                                    dispatch({ type: actionName });
                                }, timerInterval);
                            }

                            return 'break';
                        }();

                        if (_ret === 'break') break;
                    }

                case STOP_TIMER:
                    {
                        var _action$payload2 = action.payload,
                            _timerName = _action$payload2.timerName,
                            _action$payload2$time = _action$payload2.timerNames,
                            timerNames = _action$payload2$time === undefined ? [] : _action$payload2$time;

                        timerNames.forEach(function (item) {
                            return clearTimerWithEnd(item);
                        });
                        clearTimerWithEnd(_timerName);

                        break;
                    }

                default:
                    {
                        return next(action);
                    }
            }
        };
    };
}